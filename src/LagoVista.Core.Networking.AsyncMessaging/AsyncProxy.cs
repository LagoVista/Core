using LagoVista.Core.Interfaces;
using System;
using System.Reflection;
using System.Threading.Tasks;

namespace LagoVista.Core.Networking.AsyncMessaging
{
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>
    /// Decendents of DispatchProxy cannot be sealed.
    /// Decendents of DispatchProxy cannot be internal nor private.
    /// </remarks>
    public class AsyncProxy : DispatchProxy
    {
        //todo: ML - add logger
        internal IAsyncCoupler<IAsyncResponse> AsyncCoupler { get; set; }
        internal IAsyncRequestHandler RequestSender { get; set; }
        private static MethodInfo FromResultMethodInfo { get; } = typeof(Task).GetMethod("FromResult", BindingFlags.Static | BindingFlags.Public);

        protected override object Invoke(MethodInfo targetMethod, object[] args)
        {
            var request = new AsyncRequest()
            {
                Id = Guid.NewGuid().ToString(),
                CorrelationId = Guid.NewGuid().ToString(),
                //todo: ML - write test to guarantee this name is the same as the name being generated by the AsyncRequestBroker
                Path = $"{targetMethod.DeclaringType.FullName}.{targetMethod.Name}",
                TimeStamp = DateTime.UtcNow
            };

            //todo: ML - scan params to validate names
            var parameters = targetMethod.GetParameters();
            for (var i = 0; i < parameters.Length; ++i)
            {
                request.SetValue(parameters[i].Name, args[i]);
            }

            // note: we prep that async coupler before sending the request - the coupler won't be awaited until after the call to RequestSender.HandleRequest
            var waitOnAsync = AsyncCoupler.WaitOnAsync(request.CorrelationId, TimeSpan.FromSeconds(30)).ContinueWith(waitOnAsyncTask =>
            {
                if (waitOnAsyncTask.Status == TaskStatus.Faulted && waitOnAsyncTask.Exception != null)
                {
                    //todo: ML - handle exception
                }
                else if (waitOnAsyncTask.Status != TaskStatus.RanToCompletion)
                {
                    //todo: ML - handle unexpected status
                }
                return waitOnAsyncTask.Result;
            });

            RequestSender.HandleRequest(request).ContinueWith(sendAsyncTask =>
            {
                if (sendAsyncTask.Status == TaskStatus.Faulted && sendAsyncTask.Exception != null)
                {
                    //todo: ML - handle exception
                }
                else if (sendAsyncTask.Status != TaskStatus.RanToCompletion)
                {
                    //todo: ML - handle unexpected status
                }
            });

            waitOnAsync.Wait();

            MethodInfo genericFromResult = null;
            if (targetMethod.ReturnType.BaseType == typeof(Task))
            {
                var genericArguments = targetMethod.ReturnType.GetGenericArguments();
                if (genericArguments.Length > 0)
                {
                    genericFromResult = FromResultMethodInfo.MakeGenericMethod(genericArguments);
                }
                else
                {
                    genericFromResult = FromResultMethodInfo.MakeGenericMethod();
                }
            }

            var invokeResult = waitOnAsync.Result;
            if (invokeResult.Successful)
            {
                var response = invokeResult.Result;
                if (response.Success)
                {
                    if (genericFromResult != null)
                    {
                        return genericFromResult.Invoke(null, new object[] { response.ReturnValue });
                    }
                    else
                    {
                        return response.ReturnValue;
                    }
                }
                else
                {
                    //todo: ML - response.Exception
                    if (genericFromResult != null)
                    {
                        return genericFromResult.Invoke(null, new object[] { null });
                    }
                    else
                    {
                        return null;
                    }
                }
            }
            else
            {
                //todo: ML - handle failed invoke result
                if (genericFromResult != null)
                {
                    return genericFromResult.Invoke(null, new object[] { null });
                }
                else
                {
                    return null;
                }
            }
        }
    }
}
